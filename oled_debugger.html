<!DOCTYPE html>
<html lang="zh">
<!--本程序由DeepSeek生成-->

<head>
    <meta charset="utf-8">
    <title>OLED 绘图工具</title>
    <style>
        /* 基础样式 */
        html {
            background-color: #000000;
        }

        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 0 20px;
        }

        /* 画布样式 */
        canvas {
            /* 放大显示尺寸 */
            width: 512px;
            height: 256px;
            image-rendering: pixelated;
            /* 保持像素锐利 */
            cursor: none;
            /* 隐藏默认鼠标指针 */
        }

        /* 工具区布局 */
        .tools {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* 状态指示器样式 */
        .coords-display {
            background: #f0f0f0;
            padding: 8px 15px;
            border-radius: 4px;
            font-family: monospace;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-top: 10px;
            /* 默认显示 */
            display: flex;
        }

        /* 按钮基础样式 */
        button {
            padding: 8px 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        select {
            padding: 7px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
    </style>
</head>

<body>
    <!-- 状态指示区 -->
    <div id="coordsDisplay" class="coords-display">coordinate:(X:0,Y:0)</div>
    <br>
    <!-- 主画布 -->
    <canvas id="pixelCanvas"></canvas>
    <div id="pixelIndicator" class="pixel-indicator"></div>
    <br>
    <!-- 工具控制区 -->
    <div class="tools">
        <button onclick="clearCanvas()">清除画板</button>
        <select id="toolSelect" onchange="changeTool(this.value)">
            <option value="free">自由绘制</option>
            <option value="line">直线工具</option>
        </select>
        <button onclick="exportSSD1306()">导出数据</button>
    </div>
    <br>
    <!-- 数据输出容器 -->
    <div id="output" style="margin-top:20px;">
        <!-- 常驻文本域和按钮 -->
        <textarea id="exportOutput" style="width:75%; height:200px; font-family:monospace; display:block"></textarea>
        <br><button onclick="copyExportedData()" style="margin-top:5px;">
            复制到剪贴板
        </button>
    </div>

    <script>

        // ======================
        // 画布初始化模块
        // ======================
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const indicator = document.getElementById('pixelIndicator');
        // 设置物理像素尺寸（实际分辨率）
        canvas.width = 128;  // SSD1306 的典型宽度
        canvas.height = 64;  // SSD1306 的典型高度

        // 初始化白色画布
        let imageData = ctx.createImageData(canvas.width, canvas.height);
        // 填充白色背景（RGBA格式）
        for (let i = 0; i < imageData.data.length; i += 4) {
            imageData.data[i] = 255;     // R
            imageData.data[i + 1] = 255; // G
            imageData.data[i + 2] = 255; // B
            imageData.data[i + 3] = 255; // A（完全不透明）
        }
        ctx.putImageData(imageData, 0, 0);
        // ======================
        // 新增预览颜色配置
        // ======================
        const PREVIEW_COLOR = '#FF0000'; // 红色预览
        const PREVIEW_OPACITY = 0.6;     // 60%透明度

        // ======================
        // 坐标转换系统
        // ======================
        let canvasRect = canvas.getBoundingClientRect();

        /**
         * 更新画布位置信息（窗口变化时调用）
         */
        function updateCanvasRect() {
            canvasRect = canvas.getBoundingClientRect();
        }

        /**
         * 将鼠标坐标转换为画布像素坐标
         * @param {MouseEvent} event - 鼠标事件对象
         * @returns {Object} 包含x,y的像素坐标对象
         */
        function getPixelPosition(event) {
            return {
                x: Math.min(canvas.width - 1,
                    Math.max(0,
                        Math.floor(
                            (event.clientX - canvasRect.left) /
                            canvasRect.width * canvas.width
                        ))
                ),
                y: Math.min(canvas.height - 1,
                    Math.max(0,
                        Math.floor(
                            (event.clientY - canvasRect.top) /
                            canvasRect.height * canvas.height
                        )
                    )
                )
            };
        }

        // 更新指示器位置
        function updateIndicator(pos) {
            const pixelWidth = canvasRect.width / canvas.width;
            const pixelHeight = canvasRect.height / canvas.height;

            // 添加边界检查
            pos.x = Math.max(0, Math.min(canvas.width - 1, pos.x));
            pos.y = Math.max(0, Math.min(canvas.height - 1, pos.y));

            // 精确对齐像素边界
            indicator.style.left = `${canvasRect.left + pos.x * pixelWidth}px`;
            indicator.style.top = `${canvasRect.top + pos.y * pixelHeight}px`;

            // 动态调整指示器尺寸
            indicator.style.width = `${Math.ceil(pixelWidth)}px`;
            indicator.style.height = `${Math.ceil(pixelHeight)}px`;

            // 保持可见性
            indicator.style.display = 'block';
            coordsDisplay.style.display = 'block';
        }


        // 隐藏指示器
        function hideIndicator() {
            indicator.style.display = 'none';
            coordsDisplay.style.display = 'none';
        }
        // ======================
        // 状态指示系统
        // ======================
        const coordsDisplay = document.getElementById('coordsDisplay');

        /**
         * 更新坐标显示
         * @param {Object} pos - 包含x,y的坐标对象
         */
        function updateCoordsDisplay(pos) {
            coordsDisplay.textContent = `coordinate:(X:${pos.x},Y:${pos.y})`;
        }

        // ======================
        // 绘图核心逻辑
        // ======================
        /**
         * 设置单个像素颜色
         * @param {number} x - X坐标
         * @param {number} y - Y坐标
         * @param {boolean} isBlack - 是否为黑色像素
         */
        function setPixel(x, y, isBlack) {
            const index = (y * canvas.width + x) * 4;
            const value = isBlack ? 0 : 255;
            imageData.data[index] = value;     // R
            imageData.data[index + 1] = value; // G
            imageData.data[index + 2] = value; // B
            // 注意:保留Alpha通道不变
        }

        /**
         * Bresenham 直线算法
         * @param {number} x1 - 起点X
         * @param {number} y1 - 起点Y
         * @param {number} x2 - 终点X
         * @param {number} y2 - 终点Y
         * @param {boolean} isBlack - 绘制颜色
         */
        function drawLine(x1, y1, x2, y2, isBlack) {
            const dx = Math.abs(x2 - x1);
            const dy = -Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx + dy;

            while (true) {
                setPixel(x1, y1, isBlack);
                if (x1 === x2 && y1 === y2) break;
                const e2 = 2 * err;
                if (e2 >= dy) { err += dy; x1 += sx; }
                if (e2 <= dx) { err += dx; y1 += sy; }
            }
        }
        let previewImageData = null; // 用于存储预览前的画布状态


        // ======================
        // 修改后的直线绘制逻辑
        // ======================
        /**
         * 实时预览直线（不修改实际图像数据）
         * @param {number} endX - 终点X坐标
         * @param {number} endY - 终点Y坐标
         * @param {boolean} isBlack - 线段颜色
         */
        function previewLine(endX, endY, isBlack) {
            ctx.putImageData(previewImageData, 0, 0);

            // 创建临时canvas实现预览效果
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false;

            // 使用混合模式保持二值化核心
            tempCtx.globalCompositeOperation = 'source-over';
            tempCtx.fillStyle = PREVIEW_COLOR;
            tempCtx.globalAlpha = PREVIEW_OPACITY;

            // Bresenham算法绘制预览线
            let x1 = startPos.x, y1 = startPos.y;
            let x2 = endX, y2 = endY;

            const dx = Math.abs(x2 - x1);
            const dy = -Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx + dy;

            while (true) {
                // 绘制半透明红色方块
                tempCtx.fillRect(x1, y1, 1, 1);
                if (x1 === x2 && y1 === y2) break;
                const e2 = 2 * err;
                if (e2 >= dy) { err += dy; x1 += sx; }
                if (e2 <= dx) { err += dx; y1 += sy; }
            }

            // 叠加到主画布
            ctx.drawImage(tempCanvas, 0, 0);
        }
        // ======================
        // 修改直线绘制完成逻辑
        // ======================
        function finishLine(endX, endY, isBlack) {
            drawLine(startPos.x, startPos.y, endX, endY, isBlack);
            ctx.putImageData(imageData, 0, 0);
            startPos = null;
            previewImageData = null; // 清除预览缓存
        }

        // ======================
        // 工具事件处理
        // ======================
        let currentTool = 'free';
        let startPos = null;
        let lastPos = null;

        /**
         * 切换绘图工具
         * @param {string} tool - 工具标识符
         */
        function changeTool(tool) {
            currentTool = tool;
            startPos = null;
            ctx.putImageData(imageData, 0, 0); // 清除预览
        }




        // ======================
        // 数据生成模块
        // ======================
        /**
         * 生成显示数据
         * @returns {Uint8Array} 1024字节的显示数据
         */
        function generateSSD1306Data() {
            const buffer = new Uint8Array(128 * 8); // 128列 x 8页

            // 遍历每个页（8页，每页8行）
            for (let page = 0; page < 8; page++) {
                // 遍历每列（128列）
                for (let x = 0; x < 128; x++) {
                    let byte = 0;

                    // 组合8个垂直像素为一个字节
                    for (let bit = 0; bit < 8; bit++) {
                        const y = page * 8 + bit;
                        const idx = (y * 128 + x) * 4;

                        // 判断像素颜色（黑色为1）
                        const isBlack = (
                            imageData.data[idx] === 0 &&
                            imageData.data[idx + 1] === 0 &&
                            imageData.data[idx + 2] === 0
                        );

                        // 将像素值设置到字节的正确位置
                        // 要求最高位bit7对应页顶部的像素
                        byte |= (isBlack ? 1 : 0) << bit;

                    }

                    buffer[page * 128 + x] = byte;
                }
            }
            return buffer;
        }

        // ======================
        // 数据导出模块
        // ======================
        /**
         * 执行数据导出操作
         */
        function exportSSD1306() {
            const data = generateSSD1306Data();
            const outputTextarea = document.getElementById('exportOutput');
            // 处理不同格式
            let output = "";

            output = `const uint8_t bitmap[1024] = {\n  `;
            data.forEach((byte, i) => {
                output += `0x${byte.toString(16).padStart(2, '0')}`;
                output += (i !== data.length - 1) ? ", " : "";
                if ((i + 1) % 16 === 0) output += "\n  ";
            });
            output += "};";
            // 更新常驻文本域
            outputTextarea.value = output;
        }
        // ======================
        // 新增复制函数
        // ======================
        function copyExportedData() {
            const textarea = document.getElementById('exportOutput');
            textarea.select();
            document.execCommand('copy');
            textarea.blur();
        }
        // ======================
        // 工具函数
        // ======================
        function clearCanvas() {
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i] = 255;
                imageData.data[i + 1] = 255;
                imageData.data[i + 2] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
        }
        // ======================
        // 工具切换逻辑
        // ======================
        function changeTool(tool) {
            if (currentTool === 'line' && startPos) {
                // 切换工具时自动取消未完成的直线
                ctx.putImageData(previewImageData, 0, 0);
                startPos = null;
                previewImageData = null;
            }
            currentTool = tool;
            ctx.putImageData(imageData, 0, 0);
        }
        // 鼠标事件监听
        canvas.addEventListener('mousemove', function (e) {
            const pos = getPixelPosition(e);
            updateCoordsDisplay(pos);
            updateIndicator(pos);

            // 直线预览模式
            if (currentTool === 'line' && startPos) {
                previewLine(pos.x, pos.y, e.buttons === 1);
                return; // 阻断自由绘制逻辑
            }

            // 自由绘制模式（仅在非直线工具时生效）
            if (currentTool !== 'line' && (e.buttons & 3)) {
                const isBlack = e.buttons & 1;
                if (lastPos) {
                    drawLine(lastPos.x, lastPos.y, pos.x, pos.y, isBlack);
                } else {
                    setPixel(pos.x, pos.y, isBlack);
                }
                ctx.putImageData(imageData, 0, 0);
                lastPos = pos;
            }

            // 新增边界检查
            if (!startPos) return;
            // 限制预览范围
            const boundedX = Math.max(0, Math.min(canvas.width - 1, pos.x));
            const boundedY = Math.max(0, Math.min(canvas.height - 1, pos.y));
            previewLine(boundedX, boundedY, e.buttons === 1);
        });
        // ======================
        // 修改鼠标事件处理
        // ======================
        canvas.addEventListener('mousedown', function (e) {
            const pos = getPixelPosition(e);
            const isBlack = e.button === 0;

            if (currentTool === 'line') {
                if (!startPos) {
                    // 记录起点并保存当前画布状态
                    startPos = pos;
                    previewImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                } else {
                    // 正式绘制直线
                    drawLine(startPos.x, startPos.y, pos.x, pos.y, isBlack);
                    ctx.putImageData(imageData, 0, 0);
                    startPos = null;
                }
            } else {
                // 自由绘制模式
                setPixel(pos.x, pos.y, isBlack);
                ctx.putImageData(imageData, 0, 0);
                lastPos = pos;
            }
        });
        // ======================
        // 新增全局事件监听
        // ======================
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && currentTool === 'line' && startPos) {
                // 恢复预览前状态
                ctx.putImageData(previewImageData, 0, 0);
                // 重置绘制状态
                startPos = null;
                previewImageData = null;
                // 更新坐标显示
                coordsDisplay.textContent = 'coordinate:(X:0,Y:0)';
            }
        });
        // ======================
        // 窗口事件监听
        // ======================
        window.addEventListener('scroll', updateCanvasRect, true); canvas.addEventListener('mouseenter', updateCanvasRect);
        canvas.addEventListener('mouseleave', () => {
            coordsDisplay.textContent = 'coordinate:(X:0,Y:0)';
        });
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(updateCanvasRect, 100);
        });
    </script>
    <style>
        /* 优化指示器样式 */
        .pixel-indicator {
            position: fixed;
            /* 改为fixed定位 */
            z-index: 9999;
            background: rgba(0, 255, 0, 0.5);
            /*box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);*/
            /*transition: all 50ms linear;*/
            /* 添加平滑移动效果 */
            pointer-events: none;
            display: none;
            /* 初始隐藏 */
        }

        #exportOutput {
            border: 1px solid #ccc;
            padding: 10px;
            margin: 10px 0;
            resize: vertical;
            min-height: 150px;
        }
    </style>
</body>

</html>
